Language: X'
Syntax:
#this is a comment
any var #any type
bool bolean #true or false
str string #string
arr array = create array ((str)type,n, length) #an n-dimesional array with type type (int,str,bool,static,int,uint8,uint16)
static constant #constant. Can’t change. Will error if undefined
int whole #if you try to set it to an non-integer value, it sets to that value rounded down
uint8 Nonsigned8 # unsigned 8 bit integer
uint16 Nonsigned16 # unsigned 16 bit integer
var = 1 #set var
int = 1.1 #int goes to 1
constant  = 1 #it is annoying that programing languages error if you try to change a const, so nothing happens here
var += 1 #sets var to var + 1
#operators:
a + b
a - b
a * b
a / b
a ** b
#Accepted variable characters:
A-Z
a-z
0-9
_
#these combined into any string ex:
#_anjkn333 1mkfdk anjknm1_
#Special constants:
/\s/ #space
/\n/ # new line
/\t/ # tab
#C-blocks:
if bool {
  …
}
while bool {
  …
}
for (let i = a, i < b, i += s) {
  …
}


#Function for indenting (in js):
function indent(code){
    let lines = code.split(`\n`)
    let n = 0
    for (let lineI in lines){
        for (let c of lines[lineI]){
            if (c == '}') n--
            if(c == '#') break
        }
        while (lines[lineI][0] == `\t`){
            lines[lineI] = lines[lineI].slice(1)
        }
        lines[lineI] = `\t`.repeat(n) + lines[lineI]
        for (let c of lines[lineI]){
            if (c == '{') n++
            if(c == '#') break
        }
    }
    if (!(n == 0)) throw new Error('unmatching {}')
    let str = lines.join(`\n`)
    return str
}
#Function syntax:
any func = (params) -> {
  …
}
#Class syntax:
class Class{
  …
}

#constructor syntax:
constructor = (params) -> {
  any this.params = params
}
#Method syntax:
method = (inp) -> {
  …
}
#Other:
return val #returns value
array.length #length of array
array[i] item at index i of array
Xprime.key #null if no key is pressed, otherwise it is the key that is pressed

#Making a class:
Class example #first is the class, second is name. Kinda like processing

#GRAPHICS:
Xprime.createWindow(width,height,align)
Graphic render = create Graphic(width,height) #creates a graphics window that you can render on
Renderer renderer = render.createRenderer(mode,align) #mode can by pixel or vector
GRAPHICS vector syntax:
renderer.fill = fill #string or list of r,g,b. String can be js default colors or none
renderer.rect(x,y,width,height) #rectangle
renderer.arc(centerX,centerY,startAngle,endAngle, radx, rady, bool counterclowise) #arc
renderer.pathStyle = style #either ‘bezier’ or ‘straight’ bezier just for every vertex v3, middle vertex (first previous) v2, and 2nd previous v1, it draws a quadratic
renderer.beginPath() #begin path
renderer.vertex(x,y) #creates a vertex
renderer.endPath() #ends path
GRAPHICS all:
renderer.drawImg(imageData, x, y, (optional: transW, transH,angle)) #puts image at x,y and can transform the image into width transW height transH
renderer.getImgData(src) #gets image and turns it into an image data object with data, W, H
GRAPHICS pixel:
arr px = renderer.px #gets the pixels currently on render. Creates array:
#px = new array(‘any’, 3)
#px.map(()[all] -> new array(‘uint8’,1))
MAIN LOOP:
any main = () -> {
  #code
  Xprime.loop(main)
}

main()

#Ex program:
bool keyPressed = (searchKey) -> {
  return Xprime.key == searchKey
}

class Player{
  constructor = (x,y) -> {
    this.x = x
    this.y = y
    this.speed = 5
  }
  move(){
    this.x += this.speed * ((keyPressed('w') || keyPressed('up')) - (keyPressed('s') || keyPressed('down')))
    this.y += this.speed * ((keyPressed('d') || keyPressed('right')) - (keyPressed('a') || keyPressed('left')))
  }
}

Xprime.createWindow(400,400)
Graphic world = create Graphic(400,400,'center')
Player player = create Player(0,0)
Renderer draw = world.createRenderer('vector','center')
any main = () -> {
  Player.move
  draw.fillRect(player.x,player.y,20,20)
  player.move()
  Xprime.loop(main)
}
main()
